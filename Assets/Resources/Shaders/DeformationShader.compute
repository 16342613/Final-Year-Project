// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalculateDistance

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

RWStructuredBuffer<vector> originalVertexBuffer;
RWStructuredBuffer<vector> vertexBuffer;
RWStructuredBuffer<vector> vertexVelocitiesBuffer;
float forceAmount;
vector forceOrigin;
float meshStrength;
float vertexMass;
int vertexCount;
float uniformScale;
float springForce;
float damping;
float time;

[numthreads(1, 1, 1)]
void CalculateDistance(uint3 id : SV_DispatchThreadID)
{
    if(id.x < vertexCount) 
    {
        originalVertexBuffer[id.x].w = 0;
        forceOrigin.w = 0;
        vertexBuffer[id.x].w = 0;

        float distanceFromForce = sqrt(((vertexBuffer[id.x].x - forceOrigin.x) * (vertexBuffer[id.x].x - forceOrigin.x))
                                    + ((vertexBuffer[id.x].y - forceOrigin.y) * (vertexBuffer[id.x].y - forceOrigin.y))
                                    + ((vertexBuffer[id.x].z - forceOrigin.z) * (vertexBuffer[id.x].z - forceOrigin.z)));
                                
        if (distanceFromForce > 0.5) 
        {
            return;
        }

        float forceAtVertex = forceAmount / (meshStrength + 5 * (distanceFromForce * distanceFromForce));
        float vertexAcceleration = forceAtVertex / vertexMass;
        vertexVelocitiesBuffer[id.x] = normalize(vertexBuffer[id.x] - forceOrigin) * vertexAcceleration;

        vector displacement = originalVertexBuffer[id.x] - vertexBuffer[id.x];
        displacement = displacement * uniformScale;

        vector reboundVelocity = displacement * springForce;

        vertexVelocitiesBuffer[id.x] = vertexVelocitiesBuffer[id.x] - reboundVelocity;
        vertexVelocitiesBuffer[id.x] = vertexVelocitiesBuffer[id.x] * (1 - damping * time);

        //vertexBuffer[id.x] = vertexBuffer[id.x] + (vertexVelocitiesBuffer[id.x] * time);
    }
}
