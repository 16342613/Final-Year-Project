// DEBUG
RWStructuredBuffer<float3> debugBuffer;

// Read Only
RWStructuredBuffer<int> squareVertices;
RWStructuredBuffer<float3> meshVertices;
RWStructuredBuffer<float4x4> IM_TRSMs;
RWStructuredBuffer<int> collidersToUpdate;
RWStructuredBuffer<float4x4> CC_TRSMs;
RWStructuredBuffer<float3> meshNormals;

// Write Only
RWStructuredBuffer<float3> boxColliderCentres;

// Read and Write

// FROM https://gist.github.com/aeroson/043001ca12fe29ee911e
float4 LookRotation(float3 forward, float3 up)
{
    forward = normalize(forward);
    float3 right = normalize(cross(up, forward));
    up = cross(forward, right);
    float m00 = right.x;
    float m01 = right.y;
    float m02 = right.z;
    float m10 = up.x;
    float m11 = up.y;
    float m12 = up.z;
    float m20 = forward.x;
    float m21 = forward.y;
    float m22 = forward.z;


    float num8 = (m00 + m11) + m22;
    float4 quaternion = float4(0, 0, 0, 0);
    
    if (num8 > 0)
    {
        float num = sqrt(num8 + 1);
        quaternion.w = num * 0.5;
        num = 0.5 / num;
        quaternion.x = (m12 - m21) * num;
        quaternion.y = (m20 - m02) * num;
        quaternion.z = (m01 - m10) * num;
        
        return quaternion;
    }
    if ((m00 >= m11) && (m00 >= m22))
    {
        float num7 = sqrt(((1 + m00) - m11) - m22);
        float num4 = 0.5 / num7;
        quaternion.x = 0.5 * num7;
        quaternion.y = (m01 + m10) * num4;
        quaternion.z = (m02 + m20) * num4;
        quaternion.w = (m12 - m21) * num4;
        
        return quaternion;
    }
    if (m11 > m22)
    {
        float num6 = sqrt(((1 + m11) - m00) - m22);
        float num3 = 0.5 / num6;
        quaternion.x = (m10 + m01) * num3;
        quaternion.y = 0.5 * num6;
        quaternion.z = (m21 + m12) * num3;
        quaternion.w = (m20 - m02) * num3;
        
        return quaternion;
    }
    
    float num5 = sqrt(((1 + m22) - m00) - m11);
    float num2 = 0.5 / num5;
    quaternion.x = (m20 + m02) * num2;
    quaternion.y = (m21 + m12) * num2;
    quaternion.z = 0.5 * num5;
    quaternion.w = (m01 - m10) * num2;

    return float4(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
}

float3 TransformPoint(float3 toTransform, float4x4 trsMatrix)
{
    float3 vector3;
    
    vector3[0] = (trsMatrix[0][0] * toTransform[0] + trsMatrix[0][1] * toTransform[1] + trsMatrix[0][2] * toTransform[2]) + trsMatrix[0][3];
    vector3[1] = (trsMatrix[1][0] * toTransform[0] + trsMatrix[1][1] * toTransform[1] + trsMatrix[1][2] * toTransform[2]) + trsMatrix[1][3];
    vector3[2] = (trsMatrix[2][0] * toTransform[0] + trsMatrix[2][1] * toTransform[1] + trsMatrix[2][2] * toTransform[2]) + trsMatrix[2][3];
    float num = float1(1) / ((trsMatrix[3][0] * toTransform[0] + trsMatrix[3][1] * toTransform[1] + trsMatrix[3][2] * toTransform[2]) + trsMatrix[3][3]);
    vector3[0] = vector3[0] * num;
    vector3[1] = vector3[1] * num;
    vector3[2] = vector3[2] * num;

    return vector3;
}

float3 TransformDirection(float3 toTransform, float4 rotationQuaternion)
{
    float3 t = 2 * cross(float3(rotationQuaternion[0], rotationQuaternion[1], rotationQuaternion[2]), toTransform);

    return toTransform + rotationQuaternion[3] * t + cross(float3(rotationQuaternion[0], rotationQuaternion[1], rotationQuaternion[2]), t);
}

float4x4 GetTranslationMatrix(float3 position)
{
    return float4x4(1, 0, 0, position[0], 
                    0, 1, 0, position[1], 
                    0, 0, 1, position[3], 
                    0, 0, 0, 1);
}

float4x4 GetRotationMatrix(float3 radianAngles)
{
    float4x4 rotationX = float4x4(1, 0, 0, 0, 
                                  0, cos(radianAngles[0]), -sin(radianAngles[0]), 0,
                                  0, sin(radianAngles[0]), cos(radianAngles[0]), 0,
                                  0, 0, 0, 1);
    
    float4x4 rotationY = float4x4(cos(radianAngles[1]), 0, sin(radianAngles[1]), 0,
                                  0, 1, 0, 0,
                                  -sin(radianAngles[1]), 0, cos(radianAngles[1]), 0,
                                  0, 0, 0, 1);
    
    float4x4 rotationZ = float4x4(cos(radianAngles[2]), -sin(radianAngles[2]), 0, 0,
                                  sin(radianAngles[2]), cos(radianAngles[2]), 0, 0,
                                  0, 0, 1, 0,
                                  0, 0, 0, 1);
    
    float4x4 x_By_y = mul(rotationX, rotationY);
    float4x4 result = mul(x_By_y, rotationZ);
    
    return result;
}

float4x4 GetScaleMatrix(float3 scale)
{
    return float4x4(scale[0], 0, 0, 0,
                    0, scale[1], 0, 0,
                    0, 0, scale[3], 0,
                    0, 0, 0, 1);
}

float4x4 ComposeTRSM(float3 position, float3 rotation, float3 scale)
{
    float4x4 translationMatrix = GetTranslationMatrix(position);
    float4x4 rotationMatrix = GetRotationMatrix(rotation);
    float4x4 scaleMatrix = GetScaleMatrix(scale);
    
    float4x4 t_by_r = mul(translationMatrix, rotationMatrix);
    float4x4 result = mul(t_by_r, scaleMatrix);

    return result;
}

float3x4 DecomposeTRSM(float4x4 TRSM)
{
    // In the order of translation, rotation, scale (ROW-MAJOR)

    float4 position = float4(TRSM[0][3], TRSM[1][3], TRSM[2][3], 0);
    float4 rotation = LookRotation(float3(TRSM[0][2], TRSM[1][2], TRSM[2][2]), float3(TRSM[0][1], TRSM[1][1], TRSM[2][1]));
    float4 scale = float4(length(float3(TRSM[0][0], TRSM[1][0], TRSM[2][0])), length(float3(TRSM[0][1], TRSM[1][1], TRSM[2][1])), length(float3(TRSM[0][2], TRSM[1][2], TRSM[2][2])), 0);

    float3x4 toReturn = float3x4(position[0], position[1], position[2], 0,
                                rotation[0], rotation[1], rotation[2], rotation[3], 
                                scale[0], scale[1], scale[2], 0);
    return toReturn;
}

float4x4 UpdatePosition(float4x4 TRSM, float3 newPosition)
{
    return float4x4(TRSM[0][0], TRSM[0][1], TRSM[0][2], newPosition[0],
                    TRSM[1][0], TRSM[1][1], TRSM[1][2], newPosition[1],
                    TRSM[2][0], TRSM[2][1], TRSM[2][2], newPosition[2],
                    TRSM[3][0], TRSM[3][1], TRSM[3][2], TRSM[3][3]);
}

#pragma kernel Main
[numthreads(3, 3, 1)]
void Main(uint3 id : SV_DispatchThreadID)
{
    //debugBuffer[id.x][id.y] = Add(id.x, id.y);

    int colliderIndex = collidersToUpdate[id.x];
    
    //squareVertices[0] = 69;
    //meshVertices[1] = float3(69, 420, 999);
    //IM_TRSMs[0][1][1] = 69;
    
    //debugBuffer[id.x] = TransformPoint(float3(2, 2, 2), IM_TRSMs[0]);
    
    float3 boxColliderCentre = float3(0, 0, 0);
    
    for (int i = 0; i < 4; i++)
    {
        boxColliderCentre = boxColliderCentre + TransformPoint(meshVertices[squareVertices[(4 * colliderIndex) + i]], IM_TRSMs[colliderIndex]);
    }
    
    boxColliderCentre = boxColliderCentre / 4;
    
    IM_TRSMs[id.x] = GetRotationMatrix(debugBuffer[0]);
    
    /*float3x4 originalCC_Decomposed = DecomposeTRSM(CC_TRSMs[0]);
    float4 originalCC_rotation = float4(originalCC_Decomposed[1][0], originalCC_Decomposed[1][1], originalCC_Decomposed[1][2], originalCC_Decomposed[1][3]);
    debugBuffer[id.x] = float3(originalCC_rotation[0], originalCC_rotation[1], originalCC_rotation[2]);*/
    
    CC_TRSMs[id.x] = UpdatePosition(CC_TRSMs[0], boxColliderCentre);
    
    float3 averageNormal = (meshNormals[squareVertices[(4 * colliderIndex) + 0]] +
                            meshNormals[squareVertices[(4 * colliderIndex) + 1]] +
                            meshNormals[squareVertices[(4 * colliderIndex) + 2]] +
                            meshNormals[squareVertices[(4 * colliderIndex) + 3]]) / 4;
    
    float4 current_IM_Quaternion = DecomposeTRSM(IM_TRSMs[0])[1];
    float4 thing = LookRotation(float3(6.9, 4.2, 1), float3(2.1, 1.5, 0));
    debugBuffer[id.x] = TransformDirection(float3(1, 1, 1), thing);
    
    

}