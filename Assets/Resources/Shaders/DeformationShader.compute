struct VertexData
{
    float3 originalVertexPosition;
    float3 vertexPosition;
    float3 vertexVelocity;
    int threadID_X;
    int threadID_Y;
};

RWStructuredBuffer<float3> originalVertexBuffer;
RWStructuredBuffer<float3> vertexBuffer;
RWStructuredBuffer<float3> vertexVelocitiesBuffer;
RWStructuredBuffer<float3> debugBuffer;
float forceAmount;
float3 forceOrigin;
float meshStrength;
float vertexMass;
int vertexCount;
float uniformScale;
float springForce;
float damping;
float time;
uint threadPoolDimension;
/*
RWStructuredBuffer<VertexData> vertexData;
VertexData vertices[127][127];

#pragma kernel AssignThreads
[numthreads(1, 1, 1)]
void AssignThreads(uint3 id : SV_DispatchThreadID)
{
    uint xIndex = 0;
    uint yIndex = 0;
    uint max = 77;
    
    [unroll(6000)]
    for (int i = 0; i < vertexCount; i++)
    {
        if (xIndex < threadPoolDimension && yIndex < threadPoolDimension)
        {
            vertices[xIndex][yIndex] = vertexData[i];
        }
        
        yIndex++;
        
        if (yIndex >= max)
        {
            xIndex++;
            yIndex = 0;
        }
    }
}*/


#pragma kernel DeformVertex
[numthreads(1, 1, 1)]
void DeformVertex(uint3 id : SV_DispatchThreadID)
{
    float distanceFromForce = sqrt(((vertexBuffer[id.x].x - forceOrigin.x) * (vertexBuffer[id.x].x - forceOrigin.x))
                                    + ((vertexBuffer[id.x].y - forceOrigin.y) * (vertexBuffer[id.x].y - forceOrigin.y))
                                    + ((vertexBuffer[id.x].z - forceOrigin.z) * (vertexBuffer[id.x].z - forceOrigin.z)));
        
    if (distanceFromForce > 0.5)
    {
        return;
    }
        
    float forceAtVertex = forceAmount / (meshStrength + 5 * (distanceFromForce * distanceFromForce));
    float vertexAcceleration = forceAtVertex / vertexMass;
    vertexVelocitiesBuffer[id.x] = normalize(vertexBuffer[id.x] - forceOrigin) * vertexAcceleration;
        
    float3 displacement = originalVertexBuffer[id.x] - vertexBuffer[id.x];
    displacement = displacement * uniformScale;
        
    float3 reboundVelocity = displacement * springForce;
        
    vertexVelocitiesBuffer[id.x] = vertexVelocitiesBuffer[id.x] + reboundVelocity;
    vertexVelocitiesBuffer[id.x] = vertexVelocitiesBuffer[id.x] * (1 - damping * time);
        
    vertexBuffer[id.x] = vertexBuffer[id.x] + (vertexVelocitiesBuffer[id.x] * time);
    
    /*float distanceFromForce = sqrt(((vertices[id.x][id.y].vertexPosition.x - forceOrigin.x) * (vertices[id.x][id.y].vertexPosition.x - forceOrigin.x))
                                    + ((vertices[id.x][id.y].vertexPosition.y - forceOrigin.y) * (vertices[id.x][id.y].vertexPosition.y - forceOrigin.y))
                                    + ((vertices[id.x][id.y].vertexPosition.z - forceOrigin.z) * (vertices[id.x][id.y].vertexPosition.z - forceOrigin.z)));
        
    if (distanceFromForce > 0.5)
    {
        return;
    }
        
    float forceAtVertex = forceAmount / (meshStrength + 5 * (distanceFromForce * distanceFromForce));
    float vertexAcceleration = forceAtVertex / vertexMass;
    //vertices[id.x][id.y].vertexVelocity = normalize(vertices[id.x][id.y].vertexPosition - forceOrigin) * vertexAcceleration;
        
    float3 displacement = vertices[id.x][id.y].originalVertexPosition - vertices[id.x][id.y].vertexPosition;
    displacement = displacement * uniformScale;
        
    float3 reboundVelocity = displacement * springForce;
        
    vertices[id.x][id.y].vertexVelocity = vertices[id.x][id.y].vertexVelocity + reboundVelocity;
    vertices[id.x][id.y].vertexVelocity = vertices[id.x][id.y].vertexVelocity * (1 - damping * time);
        
    vertices[id.x][id.y].vertexPosition = vertices[id.x][id.y].vertexPosition + (vertices[id.x][id.y].vertexVelocity * time);*/
}
